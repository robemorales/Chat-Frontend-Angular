{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { InjectionToken, Injectable, Injector, Optional, Inject, NgModule } from '@angular/core';\nimport { Auth0Client } from '@auth0/auth0-spa-js';\nimport * as ɵngcc0 from '@angular/core';\nimport * as ɵngcc1 from '@angular/common';\nimport * as ɵngcc2 from '@auth0/auth0-spa-js';\nexport { InMemoryCache, LocalStorageCache, User } from '@auth0/auth0-spa-js';\nimport { BehaviorSubject, Subject, ReplaySubject, merge, defer, of, iif, from, throwError } from 'rxjs';\nimport { scan, filter, distinctUntilChanged, switchMap, mergeMap, shareReplay, concatMap, catchError, tap, takeUntil, withLatestFrom, map, take, pluck, first } from 'rxjs/operators';\nimport { __rest } from 'tslib';\nimport { Router } from '@angular/router';\nimport * as i1 from '@angular/common';\nimport { Location } from '@angular/common';\nvar useragent = {\n  name: '@auth0/auth0-angular',\n  version: '1.9.0'\n};\n\nclass Auth0ClientFactory {\n  static createClient(configFactory) {\n    const config = configFactory.get();\n\n    if (!config) {\n      throw new Error('Configuration must be specified either through AuthModule.forRoot or through AuthClientConfig.set');\n    }\n\n    const {\n      redirectUri,\n      clientId,\n      maxAge,\n      httpInterceptor\n    } = config,\n          rest = __rest(config, [\"redirectUri\", \"clientId\", \"maxAge\", \"httpInterceptor\"]);\n\n    return new Auth0Client(Object.assign(Object.assign({\n      redirect_uri: redirectUri || window.location.origin,\n      client_id: clientId,\n      max_age: maxAge\n    }, rest), {\n      auth0Client: {\n        name: useragent.name,\n        version: useragent.version\n      }\n    }));\n  }\n\n}\n\nconst Auth0ClientService = new InjectionToken('auth0.client');\nlet AbstractNavigator = /*#__PURE__*/(() => {\n  class AbstractNavigator {\n    constructor(location, injector) {\n      this.location = location;\n\n      try {\n        this.router = injector.get(Router);\n      } catch (_a) {}\n    }\n    /**\n     * Navigates to the specified url. The router will be used if one is available, otherwise it falls back\n     * to `window.history.replaceState`.\n     * @param url The url to navigate to\n     */\n\n\n    navigateByUrl(url) {\n      if (this.router) {\n        this.router.navigateByUrl(url);\n        return;\n      }\n\n      this.location.replaceState(url);\n    }\n\n  }\n\n  AbstractNavigator.ɵfac = function AbstractNavigator_Factory(t) {\n    return new (t || AbstractNavigator)(ɵngcc0.ɵɵinject(ɵngcc1.Location), ɵngcc0.ɵɵinject(ɵngcc0.Injector));\n  };\n\n  AbstractNavigator.ɵprov = i0.ɵɵdefineInjectable({\n    factory: function AbstractNavigator_Factory() {\n      return new AbstractNavigator(i0.ɵɵinject(i1.Location), i0.ɵɵinject(i0.INJECTOR));\n    },\n    token: AbstractNavigator,\n    providedIn: \"root\"\n  });\n  return AbstractNavigator;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * A custom type guard to help identify route definitions that are actually HttpInterceptorRouteConfig types.\n * @param def The route definition type\n */\n\n\nfunction isHttpInterceptorRouteConfig(def) {\n  return typeof def !== 'string';\n}\n/**\n * Gets and sets configuration for the internal Auth0 client. This can be\n * used to provide configuration outside of using AuthModule.forRoot, i.e. from\n * a factory provided by APP_INITIALIZER.\n *\n * @usage\n *\n * ```js\n * // app.module.ts\n * // ---------------------------\n * import { AuthModule, AuthClientConfig } from '@auth0/auth0-angular';\n *\n * // Provide an initializer function that returns a Promise\n * function configInitializer(\n *   http: HttpClient,\n *   config: AuthClientConfig\n * ) {\n *   return () =>\n *     http\n *       .get('/config')\n *       .toPromise()\n *       .then((loadedConfig: any) => config.set(loadedConfig));   // Set the config that was loaded asynchronously here\n * }\n *\n * // Provide APP_INITIALIZER with this function. Note that there is no config passed to AuthModule.forRoot\n * imports: [\n *   // other imports..\n *\n *   HttpClientModule,\n *   AuthModule.forRoot(),   //<- don't pass any config here\n * ],\n * providers: [\n *   {\n *     provide: APP_INITIALIZER,\n *     useFactory: configInitializer,    // <- pass your initializer function here\n *     deps: [HttpClient, AuthClientConfig],\n *     multi: true,\n *   },\n * ],\n * ```\n *\n */\n\n\nlet AuthClientConfig = /*#__PURE__*/(() => {\n  class AuthClientConfig {\n    constructor(config) {\n      if (config) {\n        this.set(config);\n      }\n    }\n    /**\n     * Sets configuration to be read by other consumers of the service (see usage notes)\n     * @param config The configuration to set\n     */\n\n\n    set(config) {\n      this.config = config;\n    }\n    /**\n     * Gets the config that has been set by other consumers of the service\n     */\n\n\n    get() {\n      return this.config;\n    }\n\n  }\n\n  AuthClientConfig.ɵfac = function AuthClientConfig_Factory(t) {\n    return new (t || AuthClientConfig)(ɵngcc0.ɵɵinject(AuthConfigService, 8));\n  };\n\n  AuthClientConfig.ɵprov = i0.ɵɵdefineInjectable({\n    factory: function AuthClientConfig_Factory() {\n      return new AuthClientConfig(i0.ɵɵinject(AuthConfigService, 8));\n    },\n    token: AuthClientConfig,\n    providedIn: \"root\"\n  });\n  return AuthClientConfig;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Injection token for accessing configuration.\n *\n * @usageNotes\n *\n * Use the `Inject` decorator to access the configuration from a service or component:\n *\n * ```\n * class MyService(@Inject(AuthConfigService) config: AuthConfig) {}\n * ```\n */\n\n\nconst AuthConfigService = new InjectionToken('auth0-angular.config');\n/**\n * Tracks the Authentication State for the SDK\n */\n\nlet AuthState = /*#__PURE__*/(() => {\n  class AuthState {\n    constructor(auth0Client) {\n      this.auth0Client = auth0Client;\n      this.isLoadingSubject$ = new BehaviorSubject(true);\n      this.refresh$ = new Subject();\n      this.accessToken$ = new ReplaySubject(1);\n      this.errorSubject$ = new ReplaySubject(1);\n      /**\n       * Emits boolean values indicating the loading state of the SDK.\n       */\n\n      this.isLoading$ = this.isLoadingSubject$.asObservable();\n      /**\n       * Trigger used to pull User information from the Auth0Client.\n       * Triggers when the access token has changed.\n       */\n\n      this.accessTokenTrigger$ = this.accessToken$.pipe(scan((acc, current) => {\n        return {\n          previous: acc.current,\n          current\n        };\n      }, {\n        current: null,\n        previous: null\n      }), filter(({\n        previous,\n        current\n      }) => previous !== current));\n      /**\n       * Trigger used to pull User information from the Auth0Client.\n       * Triggers when an event occurs that needs to retrigger the User Profile information.\n       * Events: Login, Access Token change and Logout\n       */\n\n      this.isAuthenticatedTrigger$ = this.isLoading$.pipe(filter(loading => !loading), distinctUntilChanged(), switchMap(() => // To track the value of isAuthenticated over time, we need to merge:\n      //  - the current value\n      //  - the value whenever the access token changes. (this should always be true of there is an access token\n      //    but it is safer to pass this through this.auth0Client.isAuthenticated() nevertheless)\n      //  - the value whenever refreshState$ emits\n      merge(defer(() => this.auth0Client.isAuthenticated()), this.accessTokenTrigger$.pipe(mergeMap(() => this.auth0Client.isAuthenticated())), this.refresh$.pipe(mergeMap(() => this.auth0Client.isAuthenticated())))));\n      /**\n       * Emits boolean values indicating the authentication state of the user. If `true`, it means a user has authenticated.\n       * This depends on the value of `isLoading$`, so there is no need to manually check the loading state of the SDK.\n       */\n\n      this.isAuthenticated$ = this.isAuthenticatedTrigger$.pipe(distinctUntilChanged(), shareReplay(1));\n      /**\n       * Emits details about the authenticated user, or null if not authenticated.\n       */\n\n      this.user$ = this.isAuthenticatedTrigger$.pipe(concatMap(authenticated => authenticated ? this.auth0Client.getUser() : of(null)));\n      /**\n       * Emits ID token claims when authenticated, or null if not authenticated.\n       */\n\n      this.idTokenClaims$ = this.isAuthenticatedTrigger$.pipe(concatMap(authenticated => authenticated ? this.auth0Client.getIdTokenClaims() : of(null)));\n      /**\n       * Emits errors that occur during login, or when checking for an active session on startup.\n       */\n\n      this.error$ = this.errorSubject$.asObservable();\n    }\n    /**\n     * Update the isLoading state using the provided value\n     * @param isLoading The new value for isLoading\n     */\n\n\n    setIsLoading(isLoading) {\n      this.isLoadingSubject$.next(isLoading);\n    }\n    /**\n     * Refresh the state to ensure the `isAuthenticated`, `user$` and `idTokenClaims$`\n     * reflect the most up-to-date values from  Auth0Client.\n     */\n\n\n    refresh() {\n      this.refresh$.next();\n    }\n    /**\n     * Update the access token, doing so will also refresh the state.\n     * @param accessToken The new Access Token\n     */\n\n\n    setAccessToken(accessToken) {\n      this.accessToken$.next(accessToken);\n    }\n    /**\n     * Emits the error in the `error$` observable.\n     * @param error The new error\n     */\n\n\n    setError(error) {\n      this.errorSubject$.next(error);\n    }\n\n  }\n\n  AuthState.ɵfac = function AuthState_Factory(t) {\n    return new (t || AuthState)(ɵngcc0.ɵɵinject(Auth0ClientService));\n  };\n\n  AuthState.ɵprov = i0.ɵɵdefineInjectable({\n    factory: function AuthState_Factory() {\n      return new AuthState(i0.ɵɵinject(Auth0ClientService));\n    },\n    token: AuthState,\n    providedIn: \"root\"\n  });\n  return AuthState;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet AuthService = /*#__PURE__*/(() => {\n  class AuthService {\n    constructor(auth0Client, configFactory, navigator, authState) {\n      this.auth0Client = auth0Client;\n      this.configFactory = configFactory;\n      this.navigator = navigator;\n      this.authState = authState;\n      this.appStateSubject$ = new ReplaySubject(1); // https://stackoverflow.com/a/41177163\n\n      this.ngUnsubscribe$ = new Subject();\n      /**\n       * Emits boolean values indicating the loading state of the SDK.\n       */\n\n      this.isLoading$ = this.authState.isLoading$;\n      /**\n       * Emits boolean values indicating the authentication state of the user. If `true`, it means a user has authenticated.\n       * This depends on the value of `isLoading$`, so there is no need to manually check the loading state of the SDK.\n       */\n\n      this.isAuthenticated$ = this.authState.isAuthenticated$;\n      /**\n       * Emits details about the authenticated user, or null if not authenticated.\n       */\n\n      this.user$ = this.authState.user$;\n      /**\n       * Emits ID token claims when authenticated, or null if not authenticated.\n       */\n\n      this.idTokenClaims$ = this.authState.idTokenClaims$;\n      /**\n       * Emits errors that occur during login, or when checking for an active session on startup.\n       */\n\n      this.error$ = this.authState.error$;\n      /**\n       * Emits the value (if any) that was passed to the `loginWithRedirect` method call\n       * but only **after** `handleRedirectCallback` is first called\n       */\n\n      this.appState$ = this.appStateSubject$.asObservable();\n\n      const checkSessionOrCallback$ = isCallback => iif(() => isCallback, this.handleRedirectCallback(), defer(() => this.auth0Client.checkSession()));\n\n      this.shouldHandleCallback().pipe(switchMap(isCallback => checkSessionOrCallback$(isCallback).pipe(catchError(error => {\n        const config = this.configFactory.get();\n        this.authState.setError(error);\n        this.navigator.navigateByUrl(config.errorPath || '/');\n        return of(undefined);\n      }))), tap(() => {\n        this.authState.setIsLoading(false);\n      }), takeUntil(this.ngUnsubscribe$)).subscribe();\n    }\n    /**\n     * Called when the service is destroyed\n     */\n\n\n    ngOnDestroy() {\n      // https://stackoverflow.com/a/41177163\n      this.ngUnsubscribe$.next();\n      this.ngUnsubscribe$.complete();\n    }\n    /**\n     * ```js\n     * loginWithRedirect(options);\n     * ```\n     *\n     * Performs a redirect to `/authorize` using the parameters\n     * provided as arguments. Random and secure `state` and `nonce`\n     * parameters will be auto-generated.\n     *\n     * @param options The login options\n     */\n\n\n    loginWithRedirect(options) {\n      return from(this.auth0Client.loginWithRedirect(options));\n    }\n    /**\n     * ```js\n     * await loginWithPopup(options);\n     * ```\n     *\n     * Opens a popup with the `/authorize` URL using the parameters\n     * provided as arguments. Random and secure `state` and `nonce`\n     * parameters will be auto-generated. If the response is successful,\n     * results will be valid according to their expiration times.\n     *\n     * IMPORTANT: This method has to be called from an event handler\n     * that was started by the user like a button click, for example,\n     * otherwise the popup will be blocked in most browsers.\n     *\n     * @param options The login options\n     * @param config Configuration for the popup window\n     */\n\n\n    loginWithPopup(options, config) {\n      return from(this.auth0Client.loginWithPopup(options, config).then(() => {\n        this.authState.refresh();\n      }));\n    }\n    /**\n     * ```js\n     * logout();\n     * ```\n     *\n     * Clears the application session and performs a redirect to `/v2/logout`, using\n     * the parameters provided as arguments, to clear the Auth0 session.\n     * If the `federated` option is specified it also clears the Identity Provider session.\n     * If the `localOnly` option is specified, it only clears the application session.\n     * It is invalid to set both the `federated` and `localOnly` options to `true`,\n     * and an error will be thrown if you do.\n     * [Read more about how Logout works at Auth0](https://auth0.com/docs/logout).\n     *\n     * @param options The logout options\n     */\n\n\n    logout(options) {\n      const logout = this.auth0Client.logout(options) || of(null);\n      from(logout).subscribe(() => {\n        if (options === null || options === void 0 ? void 0 : options.localOnly) {\n          this.authState.refresh();\n        }\n      });\n    }\n    /**\n     * ```js\n     * getAccessTokenSilently(options).subscribe(token => ...)\n     * ```\n     *\n     * If there's a valid token stored, return it. Otherwise, opens an\n     * iframe with the `/authorize` URL using the parameters provided\n     * as arguments. Random and secure `state` and `nonce` parameters\n     * will be auto-generated. If the response is successful, results\n     * will be valid according to their expiration times.\n     *\n     * If refresh tokens are used, the token endpoint is called directly with the\n     * 'refresh_token' grant. If no refresh token is available to make this call,\n     * the SDK falls back to using an iframe to the '/authorize' URL.\n     *\n     * This method may use a web worker to perform the token call if the in-memory\n     * cache is used.\n     *\n     * If an `audience` value is given to this function, the SDK always falls\n     * back to using an iframe to make the token exchange.\n     *\n     * Note that in all cases, falling back to an iframe requires access to\n     * the `auth0` cookie, and thus will not work in browsers that block third-party\n     * cookies by default (Safari, Brave, etc).\n     *\n     * @param options The options for configuring the token fetch.\n     */\n\n\n    getAccessTokenSilently(options = {}) {\n      return of(this.auth0Client).pipe(concatMap(client => options.detailedResponse === true ? client.getTokenSilently(Object.assign(Object.assign({}, options), {\n        detailedResponse: true\n      })) : client.getTokenSilently(options)), tap(token => this.authState.setAccessToken(typeof token === 'string' ? token : token.access_token)), catchError(error => {\n        this.authState.setError(error);\n        this.authState.refresh();\n        return throwError(error);\n      }));\n    }\n    /**\n     * ```js\n     * getTokenWithPopup(options).subscribe(token => ...)\n     * ```\n     *\n     * Get an access token interactively.\n     *\n     * Opens a popup with the `/authorize` URL using the parameters\n     * provided as arguments. Random and secure `state` and `nonce`\n     * parameters will be auto-generated. If the response is successful,\n     * results will be valid according to their expiration times.\n     */\n\n\n    getAccessTokenWithPopup(options) {\n      return of(this.auth0Client).pipe(concatMap(client => client.getTokenWithPopup(options)), tap(token => this.authState.setAccessToken(token)), catchError(error => {\n        this.authState.setError(error);\n        this.authState.refresh();\n        return throwError(error);\n      }));\n    }\n    /**\n     * ```js\n     * getUser(options).subscribe(user => ...);\n     * ```\n     *\n     * Returns the user information if available (decoded\n     * from the `id_token`).\n     *\n     * If you provide an audience or scope, they should match an existing Access Token\n     * (the SDK stores a corresponding ID Token with every Access Token, and uses the\n     * scope and audience to look up the ID Token)\n     *\n     * @remarks\n     *\n     * The returned observable will emit once and then complete.\n     *\n     * @typeparam TUser The type to return, has to extend {@link User}.\n     * @param options The options to get the user\n     */\n\n\n    getUser(options) {\n      return defer(() => this.auth0Client.getUser(options));\n    }\n    /**\n     * ```js\n     * getIdTokenClaims(options).subscribe(claims => ...);\n     * ```\n     *\n     * Returns all claims from the id_token if available.\n     *\n     * If you provide an audience or scope, they should match an existing Access Token\n     * (the SDK stores a corresponding ID Token with every Access Token, and uses the\n     * scope and audience to look up the ID Token)\n     *\n     * @remarks\n     *\n     * The returned observable will emit once and then complete.\n     *\n     * @param options The options to get the Id token claims\n     */\n\n\n    getIdTokenClaims(options) {\n      return defer(() => this.auth0Client.getIdTokenClaims(options));\n    }\n    /**\n     * ```js\n     * handleRedirectCallback(url).subscribe(result => ...)\n     * ```\n     *\n     * After the browser redirects back to the callback page,\n     * call `handleRedirectCallback` to handle success and error\n     * responses from Auth0. If the response is successful, results\n     * will be valid according to their expiration times.\n     *\n     * Calling this method also refreshes the authentication and user states.\n     *\n     * @param url The URL to that should be used to retrieve the `state` and `code` values. Defaults to `window.location.href` if not given.\n     */\n\n\n    handleRedirectCallback(url) {\n      return defer(() => this.auth0Client.handleRedirectCallback(url)).pipe(withLatestFrom(this.authState.isLoading$), tap(([result, isLoading]) => {\n        var _a;\n\n        if (!isLoading) {\n          this.authState.refresh();\n        }\n\n        const appState = result === null || result === void 0 ? void 0 : result.appState;\n        const target = (_a = appState === null || appState === void 0 ? void 0 : appState.target) !== null && _a !== void 0 ? _a : '/';\n\n        if (appState) {\n          this.appStateSubject$.next(appState);\n        }\n\n        this.navigator.navigateByUrl(target);\n      }), map(([result]) => result));\n    }\n    /**\n     * ```js\n     * buildAuthorizeUrl().subscribe(url => ...)\n     * ```\n     *\n     * Builds an `/authorize` URL for loginWithRedirect using the parameters\n     * provided as arguments. Random and secure `state` and `nonce`\n     * parameters will be auto-generated.\n     * @param options The options\n     * @returns A URL to the authorize endpoint\n     */\n\n\n    buildAuthorizeUrl(options) {\n      return defer(() => this.auth0Client.buildAuthorizeUrl(options));\n    }\n    /**\n     * ```js\n     * buildLogoutUrl().subscribe(url => ...)\n     * ```\n     * Builds a URL to the logout endpoint.\n     *\n     * @param options The options used to configure the parameters that appear in the logout endpoint URL.\n     * @returns a URL to the logout endpoint using the parameters provided as arguments.\n     */\n\n\n    buildLogoutUrl(options) {\n      return of(this.auth0Client.buildLogoutUrl(options));\n    }\n\n    shouldHandleCallback() {\n      return of(location.search).pipe(map(search => {\n        return (search.includes('code=') || search.includes('error=')) && search.includes('state=') && !this.configFactory.get().skipRedirectCallback;\n      }));\n    }\n\n  }\n\n  AuthService.ɵfac = function AuthService_Factory(t) {\n    return new (t || AuthService)(ɵngcc0.ɵɵinject(Auth0ClientService), ɵngcc0.ɵɵinject(AuthClientConfig), ɵngcc0.ɵɵinject(AbstractNavigator), ɵngcc0.ɵɵinject(AuthState));\n  };\n\n  AuthService.ɵprov = i0.ɵɵdefineInjectable({\n    factory: function AuthService_Factory() {\n      return new AuthService(i0.ɵɵinject(Auth0ClientService), i0.ɵɵinject(AuthClientConfig), i0.ɵɵinject(AbstractNavigator), i0.ɵɵinject(AuthState));\n    },\n    token: AuthService,\n    providedIn: \"root\"\n  });\n  return AuthService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet AuthGuard = /*#__PURE__*/(() => {\n  class AuthGuard {\n    constructor(auth) {\n      this.auth = auth;\n    }\n\n    canLoad(route, segments) {\n      return this.auth.isAuthenticated$.pipe(take(1));\n    }\n\n    canActivate(next, state) {\n      return this.redirectIfUnauthenticated(state);\n    }\n\n    canActivateChild(childRoute, state) {\n      return this.redirectIfUnauthenticated(state);\n    }\n\n    redirectIfUnauthenticated(state) {\n      return this.auth.isAuthenticated$.pipe(tap(loggedIn => {\n        if (!loggedIn) {\n          this.auth.loginWithRedirect({\n            appState: {\n              target: state.url\n            }\n          });\n        }\n      }));\n    }\n\n  }\n\n  AuthGuard.ɵfac = function AuthGuard_Factory(t) {\n    return new (t || AuthGuard)(ɵngcc0.ɵɵinject(AuthService));\n  };\n\n  AuthGuard.ɵprov = i0.ɵɵdefineInjectable({\n    factory: function AuthGuard_Factory() {\n      return new AuthGuard(i0.ɵɵinject(AuthService));\n    },\n    token: AuthGuard,\n    providedIn: \"root\"\n  });\n  return AuthGuard;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet AuthModule = /*#__PURE__*/(() => {\n  class AuthModule {\n    /**\n     * Initialize the authentication module system. Configuration can either be specified here,\n     * or by calling AuthClientConfig.set (perhaps from an APP_INITIALIZER factory function).\n     * @param config The optional configuration for the SDK.\n     */\n    static forRoot(config) {\n      return {\n        ngModule: AuthModule,\n        providers: [AuthService, AuthGuard, {\n          provide: AuthConfigService,\n          useValue: config\n        }, {\n          provide: Auth0ClientService,\n          useFactory: Auth0ClientFactory.createClient,\n          deps: [AuthClientConfig]\n        }]\n      };\n    }\n\n  }\n\n  AuthModule.ɵfac = function AuthModule_Factory(t) {\n    return new (t || AuthModule)();\n  };\n\n  AuthModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: AuthModule\n  });\n  AuthModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({});\n  return AuthModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet AuthHttpInterceptor = /*#__PURE__*/(() => {\n  class AuthHttpInterceptor {\n    constructor(configFactory, auth0Client, authState) {\n      this.configFactory = configFactory;\n      this.auth0Client = auth0Client;\n      this.authState = authState;\n    }\n\n    intercept(req, next) {\n      var _a;\n\n      const config = this.configFactory.get();\n\n      if (!((_a = config.httpInterceptor) === null || _a === void 0 ? void 0 : _a.allowedList)) {\n        return next.handle(req);\n      }\n\n      return this.findMatchingRoute(req, config.httpInterceptor).pipe(concatMap(route => iif( // Check if a route was matched\n      () => route !== null, // If we have a matching route, call getTokenSilently and attach the token to the\n      // outgoing request\n      of(route).pipe(pluck('tokenOptions'), concatMap(options => {\n        return this.getAccessTokenSilently(options).pipe(catchError(err => {\n          if (this.allowAnonymous(route, err)) {\n            return of('');\n          }\n\n          this.authState.setError(err);\n          return throwError(err);\n        }));\n      }), switchMap(token => {\n        // Clone the request and attach the bearer token\n        const clone = token ? req.clone({\n          headers: req.headers.set('Authorization', `Bearer ${token}`)\n        }) : req;\n        return next.handle(clone);\n      })), // If the URI being called was not found in our httpInterceptor config, simply\n      // pass the request through without attaching a token\n      next.handle(req))));\n    }\n    /**\n     * Duplicate of AuthService.getAccessTokenSilently, but with a slightly different error handling.\n     * Only used internally in the interceptor.\n     * @param options The options for configuring the token fetch.\n     */\n\n\n    getAccessTokenSilently(options) {\n      return of(this.auth0Client).pipe(concatMap(client => client.getTokenSilently(options)), tap(token => this.authState.setAccessToken(token)), catchError(error => {\n        this.authState.refresh();\n        return throwError(error);\n      }));\n    }\n    /**\n     * Strips the query and fragment from the given uri\n     * @param uri The uri to remove the query and fragment from\n     */\n\n\n    stripQueryFrom(uri) {\n      if (uri.indexOf('?') > -1) {\n        uri = uri.substr(0, uri.indexOf('?'));\n      }\n\n      if (uri.indexOf('#') > -1) {\n        uri = uri.substr(0, uri.indexOf('#'));\n      }\n\n      return uri;\n    }\n    /**\n     * Determines whether the specified route can have an access token attached to it, based on matching the HTTP request against\n     * the interceptor route configuration.\n     * @param route The route to test\n     * @param request The HTTP request\n     */\n\n\n    canAttachToken(route, request) {\n      const testPrimitive = value => {\n        if (!value) {\n          return false;\n        }\n\n        const requestPath = this.stripQueryFrom(request.url);\n\n        if (value === requestPath) {\n          return true;\n        } // If the URL ends with an asterisk, match using startsWith.\n\n\n        return value.indexOf('*') === value.length - 1 && request.url.startsWith(value.substr(0, value.length - 1));\n      };\n\n      if (isHttpInterceptorRouteConfig(route)) {\n        if (route.httpMethod && route.httpMethod !== request.method) {\n          return false;\n        }\n        /* istanbul ignore if */\n\n\n        if (!route.uri && !route.uriMatcher) {\n          console.warn('Either a uri or uriMatcher is required when configuring the HTTP interceptor.');\n        }\n\n        return route.uriMatcher ? route.uriMatcher(request.url) : testPrimitive(route.uri);\n      }\n\n      return testPrimitive(route);\n    }\n    /**\n     * Tries to match a route from the SDK configuration to the HTTP request.\n     * If a match is found, the route configuration is returned.\n     * @param request The Http request\n     * @param config HttpInterceptorConfig\n     */\n\n\n    findMatchingRoute(request, config) {\n      return from(config.allowedList).pipe(first(route => this.canAttachToken(route, request), null));\n    }\n\n    allowAnonymous(route, err) {\n      return !!route && isHttpInterceptorRouteConfig(route) && !!route.allowAnonymous && ['login_required', 'consent_required'].includes(err.error);\n    }\n\n  }\n\n  AuthHttpInterceptor.ɵfac = function AuthHttpInterceptor_Factory(t) {\n    return new (t || AuthHttpInterceptor)(ɵngcc0.ɵɵinject(AuthClientConfig), ɵngcc0.ɵɵinject(Auth0ClientService), ɵngcc0.ɵɵinject(AuthState));\n  };\n\n  AuthHttpInterceptor.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: AuthHttpInterceptor,\n    factory: AuthHttpInterceptor.ɵfac\n  });\n  return AuthHttpInterceptor;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/*\n * Public API Surface of auth0-angular\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { Auth0ClientFactory, Auth0ClientService, AuthClientConfig, AuthConfigService, AuthGuard, AuthHttpInterceptor, AuthModule, AuthService, AuthState, isHttpInterceptorRouteConfig, AbstractNavigator as ɵa }; //# sourceMappingURL=auth0-auth0-angular.js.map","map":null,"metadata":{},"sourceType":"module"}