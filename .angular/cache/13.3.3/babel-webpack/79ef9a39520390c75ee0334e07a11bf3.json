{"ast":null,"code":"import _asyncToGenerator from \"C:\\\\Users\\\\HP\\\\Documents\\\\chat\\\\Chat-Frontend-Angular\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\asyncToGenerator.js\";\n// Licensed to the .NET Foundation under one or more agreements.\n// The .NET Foundation licenses this file to you under the MIT license.\nimport { LogLevel } from \"./ILogger\";\nimport { TransferFormat } from \"./ITransport\";\nimport { Arg, getDataDetail, getUserAgentHeader, Platform, sendMessage } from \"./Utils\";\n/** @private */\n\nexport class ServerSentEventsTransport {\n  constructor(httpClient, accessTokenFactory, logger, options) {\n    this._httpClient = httpClient;\n    this._accessTokenFactory = accessTokenFactory;\n    this._logger = logger;\n    this._options = options;\n    this.onreceive = null;\n    this.onclose = null;\n  }\n\n  connect(url, transferFormat) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      Arg.isRequired(url, \"url\");\n      Arg.isRequired(transferFormat, \"transferFormat\");\n      Arg.isIn(transferFormat, TransferFormat, \"transferFormat\");\n\n      _this._logger.log(LogLevel.Trace, \"(SSE transport) Connecting.\"); // set url before accessTokenFactory because this.url is only for send and we set the auth header instead of the query string for send\n\n\n      _this._url = url;\n\n      if (_this._accessTokenFactory) {\n        const token = yield _this._accessTokenFactory();\n\n        if (token) {\n          url += (url.indexOf(\"?\") < 0 ? \"?\" : \"&\") + `access_token=${encodeURIComponent(token)}`;\n        }\n      }\n\n      return new Promise((resolve, reject) => {\n        let opened = false;\n\n        if (transferFormat !== TransferFormat.Text) {\n          reject(new Error(\"The Server-Sent Events transport only supports the 'Text' transfer format\"));\n          return;\n        }\n\n        let eventSource;\n\n        if (Platform.isBrowser || Platform.isWebWorker) {\n          eventSource = new _this._options.EventSource(url, {\n            withCredentials: _this._options.withCredentials\n          });\n        } else {\n          // Non-browser passes cookies via the dictionary\n          const cookies = _this._httpClient.getCookieString(url);\n\n          const headers = {};\n          headers.Cookie = cookies;\n          const [name, value] = getUserAgentHeader();\n          headers[name] = value;\n          eventSource = new _this._options.EventSource(url, {\n            withCredentials: _this._options.withCredentials,\n            headers: { ...headers,\n              ..._this._options.headers\n            }\n          });\n        }\n\n        try {\n          eventSource.onmessage = e => {\n            if (_this.onreceive) {\n              try {\n                _this._logger.log(LogLevel.Trace, `(SSE transport) data received. ${getDataDetail(e.data, _this._options.logMessageContent)}.`);\n\n                _this.onreceive(e.data);\n              } catch (error) {\n                _this._close(error);\n\n                return;\n              }\n            }\n          }; // @ts-ignore: not using event on purpose\n\n\n          eventSource.onerror = e => {\n            // EventSource doesn't give any useful information about server side closes.\n            if (opened) {\n              _this._close();\n            } else {\n              reject(new Error(\"EventSource failed to connect. The connection could not be found on the server,\" + \" either the connection ID is not present on the server, or a proxy is refusing/buffering the connection.\" + \" If you have multiple servers check that sticky sessions are enabled.\"));\n            }\n          };\n\n          eventSource.onopen = () => {\n            _this._logger.log(LogLevel.Information, `SSE connected to ${_this._url}`);\n\n            _this._eventSource = eventSource;\n            opened = true;\n            resolve();\n          };\n        } catch (e) {\n          reject(e);\n          return;\n        }\n      });\n    })();\n  }\n\n  send(data) {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      if (!_this2._eventSource) {\n        return Promise.reject(new Error(\"Cannot send until the transport is connected\"));\n      }\n\n      return sendMessage(_this2._logger, \"SSE\", _this2._httpClient, _this2._url, _this2._accessTokenFactory, data, _this2._options);\n    })();\n  }\n\n  stop() {\n    this._close();\n\n    return Promise.resolve();\n  }\n\n  _close(e) {\n    if (this._eventSource) {\n      this._eventSource.close();\n\n      this._eventSource = undefined;\n\n      if (this.onclose) {\n        this.onclose(e);\n      }\n    }\n  }\n\n}","map":{"version":3,"sources":["C:/Users/HP/Documents/chat/Chat-Frontend-Angular/node_modules/@microsoft/signalr/dist/esm/ServerSentEventsTransport.js"],"names":["LogLevel","TransferFormat","Arg","getDataDetail","getUserAgentHeader","Platform","sendMessage","ServerSentEventsTransport","constructor","httpClient","accessTokenFactory","logger","options","_httpClient","_accessTokenFactory","_logger","_options","onreceive","onclose","connect","url","transferFormat","isRequired","isIn","log","Trace","_url","token","indexOf","encodeURIComponent","Promise","resolve","reject","opened","Text","Error","eventSource","isBrowser","isWebWorker","EventSource","withCredentials","cookies","getCookieString","headers","Cookie","name","value","onmessage","e","data","logMessageContent","error","_close","onerror","onopen","Information","_eventSource","send","stop","close","undefined"],"mappings":"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","sourcesContent":["// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\nimport { LogLevel } from \"./ILogger\";\r\nimport { TransferFormat } from \"./ITransport\";\r\nimport { Arg, getDataDetail, getUserAgentHeader, Platform, sendMessage } from \"./Utils\";\r\n/** @private */\r\nexport class ServerSentEventsTransport {\r\n    constructor(httpClient, accessTokenFactory, logger, options) {\r\n        this._httpClient = httpClient;\r\n        this._accessTokenFactory = accessTokenFactory;\r\n        this._logger = logger;\r\n        this._options = options;\r\n        this.onreceive = null;\r\n        this.onclose = null;\r\n    }\r\n    async connect(url, transferFormat) {\r\n        Arg.isRequired(url, \"url\");\r\n        Arg.isRequired(transferFormat, \"transferFormat\");\r\n        Arg.isIn(transferFormat, TransferFormat, \"transferFormat\");\r\n        this._logger.log(LogLevel.Trace, \"(SSE transport) Connecting.\");\r\n        // set url before accessTokenFactory because this.url is only for send and we set the auth header instead of the query string for send\r\n        this._url = url;\r\n        if (this._accessTokenFactory) {\r\n            const token = await this._accessTokenFactory();\r\n            if (token) {\r\n                url += (url.indexOf(\"?\") < 0 ? \"?\" : \"&\") + `access_token=${encodeURIComponent(token)}`;\r\n            }\r\n        }\r\n        return new Promise((resolve, reject) => {\r\n            let opened = false;\r\n            if (transferFormat !== TransferFormat.Text) {\r\n                reject(new Error(\"The Server-Sent Events transport only supports the 'Text' transfer format\"));\r\n                return;\r\n            }\r\n            let eventSource;\r\n            if (Platform.isBrowser || Platform.isWebWorker) {\r\n                eventSource = new this._options.EventSource(url, { withCredentials: this._options.withCredentials });\r\n            }\r\n            else {\r\n                // Non-browser passes cookies via the dictionary\r\n                const cookies = this._httpClient.getCookieString(url);\r\n                const headers = {};\r\n                headers.Cookie = cookies;\r\n                const [name, value] = getUserAgentHeader();\r\n                headers[name] = value;\r\n                eventSource = new this._options.EventSource(url, { withCredentials: this._options.withCredentials, headers: { ...headers, ...this._options.headers } });\r\n            }\r\n            try {\r\n                eventSource.onmessage = (e) => {\r\n                    if (this.onreceive) {\r\n                        try {\r\n                            this._logger.log(LogLevel.Trace, `(SSE transport) data received. ${getDataDetail(e.data, this._options.logMessageContent)}.`);\r\n                            this.onreceive(e.data);\r\n                        }\r\n                        catch (error) {\r\n                            this._close(error);\r\n                            return;\r\n                        }\r\n                    }\r\n                };\r\n                // @ts-ignore: not using event on purpose\r\n                eventSource.onerror = (e) => {\r\n                    // EventSource doesn't give any useful information about server side closes.\r\n                    if (opened) {\r\n                        this._close();\r\n                    }\r\n                    else {\r\n                        reject(new Error(\"EventSource failed to connect. The connection could not be found on the server,\"\r\n                            + \" either the connection ID is not present on the server, or a proxy is refusing/buffering the connection.\"\r\n                            + \" If you have multiple servers check that sticky sessions are enabled.\"));\r\n                    }\r\n                };\r\n                eventSource.onopen = () => {\r\n                    this._logger.log(LogLevel.Information, `SSE connected to ${this._url}`);\r\n                    this._eventSource = eventSource;\r\n                    opened = true;\r\n                    resolve();\r\n                };\r\n            }\r\n            catch (e) {\r\n                reject(e);\r\n                return;\r\n            }\r\n        });\r\n    }\r\n    async send(data) {\r\n        if (!this._eventSource) {\r\n            return Promise.reject(new Error(\"Cannot send until the transport is connected\"));\r\n        }\r\n        return sendMessage(this._logger, \"SSE\", this._httpClient, this._url, this._accessTokenFactory, data, this._options);\r\n    }\r\n    stop() {\r\n        this._close();\r\n        return Promise.resolve();\r\n    }\r\n    _close(e) {\r\n        if (this._eventSource) {\r\n            this._eventSource.close();\r\n            this._eventSource = undefined;\r\n            if (this.onclose) {\r\n                this.onclose(e);\r\n            }\r\n        }\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}